# (공통) 카메라 이동시 고려사항.md

## 0. 참고 레퍼런스
- 
##  ■■ Description ■■
- 
## 1. 카메라 이동 고려사항
## 1-1. 주요 고려점
- **대상 객체의 크기와 위치**: 객체의 바운딩 박스를 기반으로 카메라 위치를 계산
- **카메라 시점**: 객체를 최적화된 각도에서 보여주기 위한 방향 벡터 선택
- **이동 속도**: 사용자 경험을 고려한 적절한 애니메이션 지속 시간
- **이징 효과**: 부드러운 움직임을 위한 easing 함수 적용
- **성능**: 반복적인 노드 검색을 피하기 위한 캐싱机制
- **오류 처리**: 노드 찾기 실패, 카메라 컨트롤 없음 등의 예외 상황 처리
### 1-2. 세부 사항
- **바운딩 박스 계산**: `getPreciseBoundingBox()` 함수로 객체의 정확한 크기 측정
- **카메라 거리**: FOV(시야각)와 객체 크기를 기반으로 적절한 거리 계산
- **동적 확대비율**: 객체 크기에 따라 자동으로 확대/축소 비율 조정
- **캐싱**: 노드 검색 결과를 메모이제이션하여 성능 향상
### 1-3. 단계별 상세 동작
| 순서  | 동작 단계          | 상세 내용 및 연출 (Action)                                | 기술적 포인트 (Technical)                     |
| --- | -------------- | -------------------------------------------------- | --------------------------------------- |
| 01  | 객체 선택 및 강조     | 사용자가 도어 커버 클릭 시, 대상 부품군을 하이라이트 색상(Blue/Green)으로 점멸 | Raycaster 이벤트 감지 및 MeshBasicMaterial 교체 |
| 02  | 카메라 포커싱        | 커버와 힌지가 잘 보이는 최적의 뷰포트로 카메라가 부드럽게 이동                | getPreciseBoundingBox 기반 lerp 애니메이션 이동  |
| 03  | 커버 회전 (Cover)  | 가상의 경첩 축을 기준으로 커버가 120도 회전하며 개방                    | Pivot Group 설정 및 Euler 회전값 변경           |
| 04  | 케이블 분리 (Cable) | 소켓 하우징이 분리되면서 연결된 케이블이 자연스럽게 처짐(Slack)             | Skinned Mesh의 Bones 좌표 업데이트             |
| 05  | 레버 제거 (Lever)  | 고정 레버가 수직(Y축) 방향으로 Linear하게 빠져나옴                   | GSAP Timeline을 이용한 순차적 이동 (easeOut)     |
| 06  | 힌지 이탈 (Hinge)  | 힌지 어셈블리가 뒤쪽(Z축)으로 빠지며 최종 분해 완료                     | 월드 좌표계 기준 offset 이동 및 투명도 처리            |
## 2. 카메라 이동 구현 시나리오
## **1 단계**: "전체 확인" (멀리서 우측 정면, 눈높이)
1. 도어 애니메이션 동작 이후, 카메라가 3D 모델의 어느위치를 봐라보고 있던, 3D 모델의 전체 모습이 카메라에 담겨야 한다.
2. 그리고 카메라가 모델을 바라보는 위치는 지정한 노드의 높이 위치에서 정면에서 우측에 위치해야 한다.
## **2 단계**: "상세 관찰" (가까이서 로우 앵글로 접근)
1. 단순한 직선 이동은 기계적이고 딱딱해 보일 수 있다. 따라서, 이동 경로 중간에 살짝 아래로 깔리는 궤적을 그리도록 설계한다.
2. 실제 영화 촬영용 지미집이나 크레인 카메라가 아래에서 위로 훑으며 들어가는 듯한 고급스러운 영상미를 제공하도록 카메라가 이동되어야 한다.
3. 카메라 줌 이동시, 타겟 보다 낮은 위치로 이동하면서 타겟 중심을 유지하므로, 자연스럽게 올려다보는 웅장한 앵글이 완성되도록 움직여야 한다.
## **3 단계**: Orbit 효과의 재정의
1. 카메라 자체를 회전 시키는 대신, 주시점(Focus Point)이 타겟 중심에 달라붙는 연출을 강화 한다.
2. 이는 카메라가 직선으로 이동하더라도 마치 타겟을 주시하며 다가가는 듯한 고급스러운 느낌을 주도록 한다.
## 3. 카메라 이동 기능 구현시 고려 사항
### 3-1. 월드 좌표계(World Space) 를 기준으로 타겟의 위치 계산
- 카메라 이동 벡터가 **'현재 카메라의 로컬 좌표계(Local Space)'** 또는 단순 상대값에 의존하고 있어, 카메라가 회전되어 있을 때 '수평'의 의미가 왜곡될 수 있다.
- 월드 좌표계(World Space) 를 기준으로 타겟의 위치를 계산하고, 이를 순차적(Sequential)으로 실행하는 로직이 필요하다.
### 3-2. 화면 꽉참 보장
- 타겟 부품이 아무리 크거나 작더라도 카메라 화면에 잘리지 않고 전체가 들어오도록 거리를 동적으로 계산 해야 한다.
## 4. 실제 카메라가 이동할 때 그 곡선을 타지 않는 현상
- 실제 카메라가 이동할 때 그 곡선을 타지 않는 현상 은 주로 다음 두 가지 기술적 원인 때문이다.
1. **애니메이션 루프 내 `cameraControls.update()`의 자동 보간 간섭**: 
	- 많은 카메라 컨트롤 라이브러리(CameraControls, OrbitControls 등)는 자체적인 `damping`(감쇠)이나 `smoothing` 기능을 가지고 있어, `position.copy()`로 강제 설정한 값을 다시 자신들의 내부 로직으로 덮어씌워 직선처럼 보이게 만들 수 있다.
2. **`lerp`와 `Bezier`의 혼용**: 
	- 코드 내에서 위치는 Bezier로 잡더라도, `cameraControls`의 내부 상태를 업데이트하는 방식이 선형적일 경우 곡선 궤적이 상쇄된다.
3. **궤적이 완만하게 그려지는 이유:**
	- 시작점과 끝점 사이의 **중간 제어점(Control Point)** 이 두 지점과 너무 가깝거나 직선상에 가깝게 배치되어 있기 때문이다. 
	- 곡률을 높이려면 제어점을 진행 방향의 수직 벡터나 카메라의 상단(Up) 방향으로 더 멀리 밀어내야 한다.
4. **선형 이동 느낌 해결 (Path Following):**
	- 카메라가 곡선을 따라가지 않는 것처럼 느껴지는 이유는 애니메이션 루프 내에서 곡선의 좌표를 샘플링(`curve.getPoint(t)`)하지 않고, 단순히 시작/끝 위치를 `lerp`(선형 보간)하고 있기 때문일 가능성이 크다.
### 4-1. 해결 방법
- 이를 해결하기 위해, **카메라 컨트롤의 내부 보간을 잠시 끄고(damping 무시)**, 
  Bezie**r 곡선 위의 좌표를 프레임 단위로 강제 주입** 하도록 `moveCameraCinematic`의 로직을 수정해야 한다.
## 5. 카메라 컨트롤러를 사용할 때, 사용자가 의도한 **Bezier 곡선 궤적**과 실제 **카메라 이동**이 일치하지 않는(직선으로 움직이거나 궤적에서 벗어나는) 문제
- 이 현상의 핵심 원인은 **컨트롤러의 자체 보간(Damping/Inertia) 로직**이 프레임마다 
  강제로 주입된 좌표(`position.copy`)를 '급격한 변화'로 인식하여 
  부드럽게(직선에 가깝게) 보정하려고 시도하기 때문이다.
- 이를 해결하기 위해 시네마틱 애니메이션이 실행되는 동안 **임시로 Damping을 비활성화**하여, 
  카메라가 곡선 좌표를 그대로 따라가도록 강제하는 **Enterprise-grade 솔루션** 방식을 추천한다.


